/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./client/src/Player.js":
/*!******************************!*\
  !*** ./client/src/Player.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Player\": () => (/* binding */ Player),\n/* harmony export */   \"PlayerLocal\": () => (/* binding */ PlayerLocal)\n/* harmony export */ });\nconst ASSET_PATH = \"https://raw.githubusercontent.com/mgavillo/files/master/\"\n\n\nclass Player {\n    constructor(game, local, id) {\n        this.id = id\n        this.local = local;\n        this.game = game;\n        this.moveDir = [];\n        this.action = null;\n        this.mixer = null;\n        this.animations = this.game.animations;\n\n        const loader = new THREE.FBXLoader();\n        const player = this;\n        loader.load(`${ASSET_PATH}test.fbx`, function (object) {\n\n            object.mixer = new THREE.AnimationMixer(object);\n            object.castShadow = true;\n            player.mixer = object.mixer;\n            player.root = object.mixer.getRoot();\n\n            object.name = \"Character\";\n            object.traverse(function (child) {\n                if (child.isMesh) {\n                    child.castShadow = true;\n                    child.receiveShadow = true;\n                }\n            });\n            player.object = new THREE.Object3D();\n            player.object.add(object);\n            if (player.deleted === undefined) game.scene.add(player.object);\n\n            game.player.walk = object.animations[0];\n            if (player.local) {\n                game.initCameras();\n                game.animations.walk = object.animations[0];\n                if (player.initSocket !== undefined) player.initSocket();\n                game.loadEnvironment(loader);\n            } else {\n                const geometry = new THREE.BoxGeometry(100, 300, 100);\n                const material = new THREE.MeshBasicMaterial({ visible: false });\n                const box = new THREE.Mesh(geometry, material);\n                box.name = \"Collider\";\n                box.position.set(0, 150, 0);\n                player.object.add(box);\n                player.collider = box;\n                player.object.userData.id = player.id;\n                player.object.userData.remotePlayer = true;\n            }\n            if (game.animations.walk !== undefined) player.action = \"walk\";\n\n        }, null, this.onError);\n\n    }\n\n    set action(name) {\n        if (!name) return\n        if (this.actionName == name) return;\n        console.log(\"set acttion name\", name)\n        const clip = (this.local) ? this.animations[name] : THREE.AnimationClip.parse(THREE.AnimationClip.toJSON(this.animations[name]));\n        const action = this.mixer.clipAction(clip);\n        let timeScale = 1;\n        if (name == \"push-button\" || name == \"gather-objects\")\n            action.loop = THREE.LoopOnce;\n        this.actionName = name;\n        this.mixer.stopAllAction();\n\n        this.actionTime = Date.now();\n        action\n            .reset()\n            .setEffectiveTimeScale(timeScale)\n            .setEffectiveWeight(1)\n            .fadeIn(0.5)\n            .play();\n    }\n\n    get action() {\n        return this.actionName;\n    }\n\n    update(dt) {\n        if (!this.mixer) return\n        this.mixer.update(dt);\n        if (this.game.remoteData.length > 0) {\n            let found = false;\n            for (let player of this.game.remoteData) {\n                if (player.id != this.id) continue;\n                //Found the player\n                this.object.position.set(player.x, player.y, player.z);\n                const euler = new THREE.Euler(player.pb, player.heading, player.pb);\n                this.object.quaternion.setFromEuler(euler);\n                this.action = player.action;\n                found = true;\n            }\n            if (!found) this.game.removePlayer(this.id);\n        }\n    }\n}\n\nclass PlayerLocal extends Player {\n    constructor(game) {\n        super(game, true);\n\n        const player = this;\n        const socket = io.connect(\"http://localhost:3000/\");\n        socket.on('setId', function (data) {\n            player.id = data.id;\n        });\n        socket.on('remoteData', function (data) {\n            game.remoteData = data;\n        });\n        socket.on('deletePlayer', function (id) {\n            console.log(\"--------------delete players---------------\")\n            const players = game.remotePlayers.filter(function (player) {\n                if (player.id == id) {\n                    return player;\n                }\n            });\n            game.remoteData = game.remoteData.filter(function(data){\n                if(data.id == id)\n                    return false\n                else \n                    return true\n            })\n            console.log(\"players\", players)\n            if (players.length > 0) {\n\n                let index = game.remotePlayers.indexOf(players[0]);\n                if (index != -1) {\n                    game.remotePlayers.splice(index, 1);\n                    game.scene.remove(players[0].object);\n                    // game.removePlayer(id)\n                }\n            }\n            console.log(\"after\", game.remoteData)\n        });\n\n        this.socket = socket;\n    }\n\n    initSocket() {\n        console.log(\"init socket\")\n        this.socket.emit('init', {\n            x: this.object.position.x,\n            y: this.object.position.y,\n            z: this.object.position.z,\n            h: this.object.rotation.y,\n            pb: this.object.rotation.x,\n            action: \"hidle\"\n        });\n    }\n\n    updateSocket() {\n        if (this.socket !== undefined) {\n            //console.log(`PlayerLocal.updateSocket - rotation(${this.object.rotation.x.toFixed(1)},${this.object.rotation.y.toFixed(1)},${this.object.rotation.z.toFixed(1)})`);\n            this.socket.emit('update', {\n                x: this.object.position.x,\n                y: this.object.position.y,\n                z: this.object.position.z,\n                h: this.object.rotation.y,\n                pb: this.object.rotation.x,\n                action: this.actionName\n            })\n        }\n    }\n\n    blockedForward(pos, game) {\n        let dir = new THREE.Vector3(this.moveDir.x, this.moveDir.y);\n        // this.player.object.getWorldDirection(dir);\n        // if (this.player.move.forward < 0) {\n        //     console.log(\"negate\")\n        //     dir.negate();\n\n        // }\n        let raycaster = new THREE.Raycaster(pos, dir);\n        if (game.environmentProxy != undefined) {\n            const intersect = raycaster.intersectObject(game.environmentProxy);\n            if (intersect.length > 0) {\n                if (intersect[0].distance < 50)\n                    return true;\n            }\n        }\n        return false\n    }\n\n    blockedLeft(pos) {\n        let dir = new THREE.Vector3();\n        dir.set(-1, 0, 0);\n        dir.applyMatrix4(this.object.matrix);\n        dir.normalize();\n        let raycaster = new THREE.Raycaster(pos, dir);\n\n        let intersect = raycaster.intersectObject(this.environmentProxy);\n        if (intersect.length > 0) {\n            if (intersect[0].distance < 50)\n                this.object.translateX(50 - intersect[0].distance);\n        }\n    }\n\n    blockedRight(pos) {\n        let dir = new THREE.Vector3();\n        dir.set(1, 0, 0);\n        dir.applyMatrix4(this.object.matrix);\n        dir.normalize();\n        let raycaster = new THREE.Raycaster(pos, dir);\n\n        let intersect = raycaster.intersectObject(this.environmentProxy);\n        if (intersect.length > 0) {\n            if (intersect[0].distance < 50)\n                this.object.translateX(intersect[0].distance - 50);\n        }\n\n    }\n\n    bBoxFloor(game, pos, dt) {\n        let dir = new THREE.Vector3();\n        dir.set(0, -1, 0);\n        pos.y += 200;\n        let raycaster = new THREE.Raycaster(pos, dir);\n        const gravity = 60;\n        let intersect = raycaster.intersectObject(game.environmentProxy);\n        if (intersect.length > 0) {\n            const targetY = pos.y - intersect[0].distance;\n            if (targetY > this.object.position.y) {\n                //Going up\n                this.object.position.y =\n                    0.8 * this.object.position.y + 0.2 * targetY;\n                this.velocityY = 0;\n            } else if (targetY < this.object.position.y) {\n                //Falling\n                if (this.velocityY == undefined) this.velocityY = 0;\n                this.velocityY += dt * gravity;\n                this.object.position.y -= this.velocityY;\n                if (this.object.position.y < targetY) {\n                    this.velocityY = 0;\n                    this.object.position.y = targetY;\n                }\n            }\n        }\n    }\n\n    move(dt, game) {\n        const pos = this.object.position.clone();\n        pos.y += 60;\n        let blocked = false;\n        blocked = this.blockedForward(pos, game)\n\n\n        if (!blocked) {\n            const speed = this.actionName == \"run\" ? 200 : 100;\n            // this.player.object.position.x += this.player.moveDir.x * dt * speed\n            // this.player.object.position.z += this.player.moveDir.y * dt * speed\n            this.object.translateZ(dt * speed);\n        }\n        if (game.environmentProxy != undefined) {\n            // //cast left\n            // this.blockedLeft(pos)\n            // //cast right\n            // this.blockedRight(pos)\n            //cast down\n            this.bBoxFloor(game, pos, dt)\n        }\n\n    }\n\n}\n\n//# sourceURL=webpack://threerpg/./client/src/Player.js?");

/***/ }),

/***/ "./client/src/Preloader.js":
/*!*********************************!*\
  !*** ./client/src/Preloader.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Preloader\": () => (/* binding */ Preloader)\n/* harmony export */ });\nclass Preloader {\n    constructor(options) {\n        this.assets = {};\n        for (let asset of options.assets) {\n            this.assets[asset] = { loaded: 0, complete: false };\n            this.load(asset);\n        }\n        this.container = options.container;\n\n        if (options.onprogress == undefined) {\n            this.onprogress = onprogress;\n            this.domElement = document.createElement(\"div\");\n            this.domElement.style.position = \"absolute\";\n            this.domElement.style.top = \"0\";\n            this.domElement.style.left = \"0\";\n            this.domElement.style.width = \"100%\";\n            this.domElement.style.height = \"100%\";\n            this.domElement.style.background = \"#000\";\n            this.domElement.style.opacity = \"0.7\";\n            this.domElement.style.display = \"flex\";\n            this.domElement.style.alignItems = \"center\";\n            this.domElement.style.justifyContent = \"center\";\n            this.domElement.style.zIndex = \"1111\";\n            const barBase = document.createElement(\"div\");\n            barBase.style.background = \"#aaa\";\n            barBase.style.width = \"50%\";\n            barBase.style.minWidth = \"250px\";\n            barBase.style.borderRadius = \"10px\";\n            barBase.style.height = \"15px\";\n            this.domElement.appendChild(barBase);\n            const bar = document.createElement(\"div\");\n            bar.style.background = \"#2a2\";\n            bar.style.width = \"50%\";\n            bar.style.borderRadius = \"10px\";\n            bar.style.height = \"100%\";\n            bar.style.width = \"0\";\n            barBase.appendChild(bar);\n            this.progressBar = bar;\n            if (this.container != undefined) {\n                this.container.appendChild(this.domElement);\n            } else {\n                document.body.appendChild(this.domElement);\n            }\n        } else {\n            this.onprogress = options.onprogress;\n        }\n\n        this.oncomplete = options.oncomplete;\n\n        const loader = this;\n        function onprogress(delta) {\n            const progress = delta * 100;\n            loader.progressBar.style.width = `${progress}%`;\n        }\n    }\n\n    checkCompleted() {\n        for (let prop in this.assets) {\n            const asset = this.assets[prop];\n            if (!asset.complete) return false;\n        }\n        return true;\n    }\n\n    get progress() {\n        let total = 0;\n        let loaded = 0;\n\n        for (let prop in this.assets) {\n            const asset = this.assets[prop];\n            if (asset.total == undefined) {\n                loaded = 0;\n                break;\n            }\n            loaded += asset.loaded;\n            total += asset.total;\n        }\n\n        return loaded / total;\n    }\n\n    load(url) {\n        const loader = this;\n        var xobj = new XMLHttpRequest();\n        xobj.open(\"GET\", url, true);\n        xobj.onreadystatechange = function () {\n            if (xobj.readyState == 4 && xobj.status == \"200\") {\n                loader.assets[url].complete = true;\n                if (loader.checkCompleted()) {\n                    if (loader.domElement != undefined) {\n                        if (loader.container != undefined) {\n                            loader.container.removeChild(loader.domElement);\n                        } else {\n                            document.body.removeChild(loader.domElement);\n                        }\n                    }\n                    loader.oncomplete();\n                }\n            }\n        };\n        xobj.onprogress = function (e) {\n            const asset = loader.assets[url];\n            asset.loaded = e.loaded;\n            asset.total = e.total;\n            loader.onprogress(loader.progress);\n        };\n        xobj.send(null);\n    }\n}\n\n\n//# sourceURL=webpack://threerpg/./client/src/Preloader.js?");

/***/ }),

/***/ "./client/src/index.js":
/*!*****************************!*\
  !*** ./client/src/index.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Preloader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Preloader */ \"./client/src/Preloader.js\");\n/* harmony import */ var _Player__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Player */ \"./client/src/Player.js\");\n\n\n// import { io } from \"socket.io-client\";\n\n// const socket = io.connect('http://localhost:3000',\n// { upgrade: false, transports: ['websocket'], reconnection: false, forceNew: true });\n\n\n// import { Easing } from \"./Easing\";\nconst ASSET_PATH = \"https://raw.githubusercontent.com/mgavillo/files/master/\"\nconst PI = 3.141592653;\nconst PI_2 = 1.570796326;\nconst PI_3 = (3 * Math.PI) / 2;\nclass Game {\n    constructor() {\n        this.modes = Object.freeze({\n            NONE: Symbol(\"none\"),\n            PRELOAD: Symbol(\"preload\"),\n            INITIALISING: Symbol(\"initialising\"),\n            CREATING_LEVEL: Symbol(\"creating_level\"),\n            ACTIVE: Symbol(\"active\"),\n            GAMEOVER: Symbol(\"gameover\")\n        });\n        this.mode = this.modes.NONE;\n\n        this.container = document.getElementById('renderContainer')\n        this.animations = {};\n        this.camera = { object: {}, fade: 0.05 }\n        this.stats;\n        this.scene;\n        this.renderer;\n        this.controls;\n        this.debug = true;\n        const game = this;\n        this.anims = [\n            \"look-around\",\n            \"ascend-stairs\",\n            \"gather-objects\",\n            \"push-button\",\n            \"run\"\n        ];\n        const options = {\n            assets: [\n            ],\n            oncomplete: function () {\n                game.init();\n            }\n        };\n        this.anims.forEach(function (anim) {\n            options.assets.push(`${ASSET_PATH}${anim}.fbx`);\n        });\n\n        this.remotePlayers = [];\n        this.remoteColliders = [];\n        this.initialisingPlayers = [];\n        this.remoteData = [];\n\n        this.mode = this.modes.PRELOAD;\n\n        this.clock = new THREE.Clock();\n        const preloader = new _Preloader__WEBPACK_IMPORTED_MODULE_0__.Preloader(options);\n    }\n\n\n    hemisphereLight(sky = 0xE7D0A7, ground = 0x795939, intensity = 1) {\n        const light1 = new THREE.AmbientLight(0x404040); // soft white light\n        this.scene.add(light1);\n        const light = new THREE.HemisphereLight(sky, ground, intensity);\n        light.position.set(0, 200, 0);\n        return light\n    }\n\n    lensFlare() {\n        const light = new THREE.PointLight(0xffffff, 1.5, 2000);\n        light.position.set([0, 0, 60]);\n        light.rotation.set([0, 90, 0])\n        const textureLoader = new THREE.TextureLoader();\n\n        const textureFlare0 = textureLoader.load(`${ASSET_PATH}lensFlare-01.png`);\n        const textureFlare1 = textureLoader.load(`${ASSET_PATH}lensFlare1-02.png`);\n        const textureFlare2 = textureLoader.load(`${ASSET_PATH}lensFlare2-03.png`);\n\n        const lensflare = new THREE.Lensflare();\n        lensflare.addElement(new THREE.LensflareElement(textureFlare0, 512, 0));\n        lensflare.addElement(new THREE.LensflareElement(textureFlare1, 512, 10));\n        lensflare.addElement(new THREE.LensflareElement(textureFlare2, 60, 0.6));\n\n        const geometry = new THREE.BoxGeometry(0, 10, 0);\n        const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });\n        const cube = new THREE.Mesh(geometry, material);\n        this.cube.position = [0, 10, 0]\n        this.scene.add(cube);\n\n        light.add(lensflare)\n    }\n    directionalLight(color = 0xf0e2c1) {\n        const light = new THREE.DirectionalLight(color);\n        light.position.set(10, 10, 10);\n        light.rotation.set([0, -76.5494, 0])\n        light.castShadow = true;\n        light.shadow.mapSize.width = 2048;\n        light.shadow.mapSize.height = 2048;\n        light.shadow.camera.top = 3000;\n        light.shadow.camera.bottom = -3000;\n        light.shadow.camera.left = -3000;\n        light.shadow.camera.right = 3000;\n        light.shadow.camera.far = 3000;\n        // light.add(this.lensFlare())\n        return (light)\n    }\n\n    initRenderer() {\n        this.renderer = new THREE.WebGLRenderer({ antialias: true });\n        this.renderer.setPixelRatio(window.devicePixelRatio);\n        this.renderer.setSize(window.innerWidth, window.innerHeight);\n        this.renderer.alpha = true;\n        this.renderer.shadowMap.enabled = true;\n        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap; // default THREE.PCFShadowMap\n        this.renderer.shadowMapDebug = true;\n        this.container.appendChild(this.renderer.domElement);\n    }\n\n    addWindowListeners() {\n        window.addEventListener(\"resize\", function () {\n            game.onWindowResize();\n        }, false);\n        window.addEventListener(\"keydown\", function (evt) {\n            switch (evt.key) {\n                case 'ArrowDown':\n                    if (game.player.moveDir.indexOf(0) == -1)\n                        game.player.moveDir.push(0)\n                    game.player.action = \"run\"\n                    break;\n                case 'ArrowUp':\n                    if (game.player.moveDir.indexOf(PI) == -1)\n                        game.player.moveDir.push(PI)\n                    game.player.action = \"run\"\n                    break;\n                case 'ArrowLeft':\n                    if (game.player.moveDir.indexOf(PI_3) == -1)\n                        game.player.moveDir.push(PI_3)\n                    game.player.action = \"run\"\n                    break;\n                case 'ArrowRight':\n                    if (game.player.moveDir.indexOf(PI_2) == -1)\n                        game.player.moveDir.push(PI_2)\n                    // game.player.object.rotation.y = Math.PI/2;\n                    game.player.action = \"run\"\n                    break;\n            }\n        }, false)\n\n        window.addEventListener(\"keyup\", function (evt) {\n            // game.playerControlMove(0)\n            if (evt.key === 'ArrowDown')\n                game.player.moveDir.splice(game.player.moveDir.indexOf(0), 1)\n            if (evt.key === 'ArrowUp')\n                game.player.moveDir.splice(game.player.moveDir.indexOf(PI), 1)\n            if (evt.key === 'ArrowLeft')\n                game.player.moveDir.splice(game.player.moveDir.indexOf(PI_3), 1)\n            if (evt.key === 'ArrowRight')\n                game.player.moveDir.splice(game.player.moveDir.indexOf(PI_2), 1)\n            if (evt.key === 'ArrowDown' || evt.key === 'ArrowUp' || evt.key === 'ArrowRight' || evt.key === 'ArrowLeft') {\n                if (game.player.moveDir.length === 0)\n                    game.player.action = \"look-around\"\n            }\n            // game.playerControlTurn(0)\n\n        }, false)\n    }\n\n    addButtonListeners() {\n        document.getElementById(\"camera-btn\").onclick = function () {\n            game.switchCamera();\n        };\n    }\n\n    initScene(col = 0x100005) {\n        this.scene = new THREE.Scene();\n        this.scene.background = new THREE.Color(col);\n        // this.scene.fog = new THREE.Fog(col, 500, 1500);\n    }\n\n    init() {\n        this.mode = this.modes.INITIALISING;\n\n        this.createCamera()\n        this.initScene()\n\n\n        this.scene.add(this.hemisphereLight());\n        this.scene.add(this.directionalLight());\n\n\n        this.player = new _Player__WEBPACK_IMPORTED_MODULE_1__.PlayerLocal(this);\n\n        this.initRenderer();\n        this.controls = new THREE.OrbitControls(this.camera.object, this.renderer.domElement);\n\n        // stats\n        if (this.debug) {\n            this.stats = new Stats();\n            this.container.appendChild(this.stats.dom);\n        }\n        this.addWindowListeners()\n        // this.addButtonListeners()\n    }\n\n    loadSkybox() {\n        const loader = new THREE.CubeTextureLoader();\n\n        const texture = loader.load([\n            `${ASSET_PATH}bluecloud_ft.jpg`,\n            `${ASSET_PATH}bluecloud_bk.jpg`,\n            `${ASSET_PATH}bluecloud_up.jpg`,\n            `${ASSET_PATH}bluecloud_dn.jpg`,\n            `${ASSET_PATH}bluecloud_rt.jpg`,\n            `${ASSET_PATH}bluecloud_lf.jpg`,\n        ]);\n        this.scene.background = texture;\n        return (null);\n    }\n\n    loadEnvironment(loader) {\n\n        loader.load(\n            `${ASSET_PATH}island.fbx`,\n            function (object) {\n                game.scene.add(object);\n                object.receiveShadow = true;\n                object.castShadow = true;\n                object.name = \"Environment\";\n                object.traverse(function (child) {\n                    if (child.isMesh) {\n                        if (child.name.includes(\"main\")) {\n                            // child.material[0] = new THREE.MeshLambertMaterial({ color: 0x8AE7D4, envMap: game.camera.renderTarget });\n                            child.material[0] = new THREE.MeshPhysicalMaterial({\n                                reflectivity: 1.0,\n                                transmission: 0.5,\n                                roughness: 0,\n                                metalness: 0,\n                                clearcoat: 0.3,\n                                clearcoatRoughness: 0.25,\n                                color: new THREE.Color(0x8AE7D4),\n                                ior: 1.5,\n                            })\n                            child.castShadow = true;\n                            child.receiveShadow = true;\n                        } else if (child.name.includes(\"mentproxy\")) {\n                            child.material.visible = false;\n                            game.environmentProxy = child;\n                        }\n                    }\n                });\n                game.loadSkybox();\n                game.loadNextAnim(loader);\n\n            },\n            null,\n            this.onError\n        );\n    }\n\n    // createDummyEnvironment() {\n    //     const env = new THREE.Group();\n    //     env.name = \"Environment\";\n    //     this.scene.add(env);\n\n    //     const geometry = new THREE.BoxBufferGeometry(150, 150, 150);\n    //     const material = new THREE.MeshBasicMaterial({ color: 0xffff00 });\n\n    //     for (let x = -1000; x < 1000; x += 300) {\n    //         for (let z = -1000; z < 1000; z += 300) {\n    //             const block = new THREE.Mesh(geometry, material);\n    //             block.position.set(x, 75, z);\n    //             env.add(block);\n    //         }\n    //     }\n\n    //     this.environmentProxy = env;\n    // }\n\n    loadNextAnim(loader) {\n        let anim = this.anims.pop();\n        const game = this;\n        loader.load(\n            `${ASSET_PATH}${anim}.fbx`,\n            function (object) {\n                game.player.animations[anim] = object.animations[0];\n                if (game.anims.length > 0) {\n                    game.loadNextAnim(loader);\n\n                } else {\n                    delete game.anims;\n                    game.player.action = \"look-around\";\n                    game.initPlayerPosition();\n                    game.mode = game.modes.ACTIVE;\n                    game.animate();\n                }\n            },\n            null,\n            this.onError\n        );\n    }\n\n    initialOverlayAnim() {\n        const overlay = document.getElementById(\"overlay\");\n        overlay.classList.add(\"fade-in\");\n        overlay.addEventListener(\n            \"animationend\",\n            function (evt) {\n                evt.target.style.display = \"none\";\n            },\n            false\n        );\n    }\n\n    initialCameraAnim() {\n        setTimeout(function () {\n            game.player.cameras.active = game.player.cameras.back;\n            game.camera.fade = 0.01;\n            setTimeout(function () {\n                game.camera.fade = 0.1;\n            }, 1500);\n        }, 2000);\n    }\n\n    switchCamera(fade = 0.05) {\n        const cams = Object.keys(this.player.cameras);\n        cams.splice(cams.indexOf(\"active\"), 1);\n        let index;\n        for (let prop in this.player.cameras) {\n            if (this.player.cameras[prop] == this.player.cameras.active) {\n                index = cams.indexOf(prop) + 1;\n                if (index >= cams.length) index = 0;\n                this.player.cameras.active = this.player.cameras[cams[index]];\n                break;\n            }\n        }\n        this.camera.fade = fade;\n    }\n\n    initCameras() {\n        const front = new THREE.Object3D();\n        front.position.set(112, 100, 200);\n        front.parent = this.player.object;\n        const back = new THREE.Object3D();\n        back.position.set(0, 400, -650);\n        back.parent = this.player.object;\n        const wide = new THREE.Object3D();\n        wide.position.set(178, 139, 465);\n        wide.parent = this.player.object;\n        const overhead = new THREE.Object3D();\n        overhead.position.set(0, 400, 0);\n        overhead.parent = this.player.object;\n        const collect = new THREE.Object3D();\n        collect.position.set(40, 82, 94);\n        collect.parent = this.player.object;\n\n        this.player.cameras = { front, back, wide, overhead, collect };\n        this.player.cameras.active = this.player.cameras.wide;\n        this.camera.fade = 1;\n        this.initialCameraAnim()\n    }\n\n    /**\n     * @param  {} fov=80\n     * @param  {} aspect=window.innerWidth/window.innerHeight\n     * @param  {} near=1\n     * @param  {} far=2000\n     */\n    createCamera(fov = 75, aspect = window.innerWidth / window.innerHeight, near = 1, far = 20000) {\n        var width = window.innerWidth;\n        var height = window.innerHeight;\n        // this.camera.object = new THREE.OrthographicCamera(width / - 2, width / 2, height / 2, height / - 2, near, far);\n        this.camera.object = new THREE.PerspectiveCamera(fov, aspect, near, far);\n    }\n\n    /**\n     * @param  {} clientX\n     * @param  {} clientY\n     * @return pos\n     */\n    getMousePosition(clientX, clientY) {\n        const pos = new THREE.Vector2();\n        pos.x = (clientX / this.renderer.domElement.clientWidth) * 2 - 1;\n        pos.y = -(clientY / this.renderer.domElement.clientHeight) * 2 + 1;\n        return pos;\n    }\n\n    initPlayerPosition() {\n        //cast down\n        const dir = new THREE.Vector3(0, -1, 0);\n        const pos = this.player.object.position.clone();\n        pos.y += 200;\n        const raycaster = new THREE.Raycaster(pos, dir);\n        const gravity = 30;\n        const intersect = raycaster.intersectObject(this.environmentProxy);\n        if (intersect.length > 0) {\n            this.player.object.position.y = pos.y - intersect[0].distance;\n        }\n    }\n\n    // playerControlMove(forward) {\n    //     if (forward == 0)\n    //         delete this.player.move.forward;\n    //     else\n    //         this.player.move.forward = forward;\n    //     if (forward > 0) {\n    //         this.action = \"walk\";\n    //     } else if (forward < -0.2) {\n    //         this.action = \"walk\";\n    //     } else {\n    //         this.action = \"look-around\";\n    //     }\n    // }\n\n    // playerControlTurn(turn) {\n    //     if (turn == 0)\n    //         delete this.player.move.turn;\n    //     else\n    //         this.player.move.turn = turn;\n\n    // }\n\n\n    removePlayer(id) {\n        game.remotePlayers.filter(function (player) {\n            if (!player) return false\n            if (player.id == id) return false;\n            return true\n        });\n    }\n\n    rPlayerExist(id) {\n        let game = this\n        let exist = false\n        for (let i = 0; i < game.remotePlayers.length; i++){\n            if(game.remotePlayers[i].id === id)\n                return true\n        }\n        return false\n    }\n\n    createRemotePlayer(id){\n        const game = this\n        this.remoteData.forEach(function (data) {\n                if (!game.rPlayerExist(data.id) && game.player.id != data.id) {\n                    console.log(\"CREATE PLAYER\")\n                    game.remotePlayers.push(new _Player__WEBPACK_IMPORTED_MODULE_1__.Player(game, false, data.id));\n                }\n        });\n\n    }\n\n    updateRemotePlayers(dt) {\n        if (this.remoteData === undefined || this.remoteData.length == 0 || this.player === undefined || this.player.id === undefined) return;\n\n        this.createRemotePlayer()\n        this.remotePlayers.forEach(function (player) { player.update(dt); });\n    }\n\n    moveCam() {\n        var pos = this.player.object.position.clone();\n\n        this.camera.object.position.x = pos.x;\n        this.camera.object.position.y = pos.y + 600;\n        this.camera.object.position.z = pos.z + 600;\n        this.camera.object.lookAt(pos)\n\n    }\n\n    // followWithCam() {\n    //     if (this.player.cameras && this.player.cameras.active) {\n    //         this.camera.object.position.lerp(\n    //             this.player.cameras.active.getWorldPosition(new THREE.Vector3()),\n    //             this.camera.fade\n    //         );\n    //         let pos;\n    //         if (this.cameraTarget != undefined) {\n    //             this.camera.object.position.copy(this.cameraTarget.position);\n    //             pos = this.cameraTarget.target;\n    //         } else {\n    //             pos = this.player.object.position.clone();\n    //             pos.y += 60;\n    //         }\n    //         this.camera.object.lookAt(pos);\n    //     }\n    // }\n\n    animate() {\n        const game = this;\n        const dt = this.clock.getDelta();\n\n        requestAnimationFrame(function () { game.animate(); });\n\n        this.updateRemotePlayers(dt);\n\n        this.controls.update();\n        //update player anim\n        if (this.player.mixer != undefined && this.mode == this.modes.ACTIVE) { this.player.mixer.update(dt); }\n\n        //player walk\n\n        if (this.player.moveDir.length != 0) {\n            this.player.move(dt, this);\n            console.log(this.player.moveDir)\n            var turn;\n            if (this.player.moveDir.length === 2\n                && this.player.moveDir.indexOf(0) !== -1\n                && this.player.moveDir.indexOf(PI_3) !== -1) {\n                console.log(PI_3, PI * 2)\n                turn = (PI_3 + (PI * 2)) / 2\n                console.log(turn)\n\n            }\n            else {\n                var sum;\n                for (var i = 0, sum = 0; i < this.player.moveDir.length; sum += this.player.moveDir[i++]);\n                turn = sum / this.player.moveDir.length;\n\n            }\n\n            game.player.object.rotation.y = turn;\n\n        }\n        //rotate player\n        // if (this.player.move.turn != undefined) this.player.object.rotateY(this.player.move.turn * dt);\n\n        this.player.updateSocket();\n        this.moveCam()\n        this.renderer.render(this.scene, this.camera.object);\n        if (this.stats != undefined) this.stats.update();\n    }\n\n    onError(error) {\n        const msg = console.error(JSON.stringify(error));\n        console.error(error.message);\n    }\n\n    onWindowResize() {\n        this.camera.object.aspect = window.innerWidth / window.innerHeight;\n        this.camera.object.updateProjectionMatrix();\n        this.renderer.setSize(window.innerWidth, window.innerHeight);\n    }\n}\n\nvar game = new Game();\n\n\n//# sourceURL=webpack://threerpg/./client/src/index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./client/src/index.js");
/******/ 	
/******/ })()
;